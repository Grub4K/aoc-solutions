from enum import Enum
from typing import Callable, Iterable, Iterator, Literal, TypeVar, overload

T = TypeVar("T")
U = TypeVar("U")
_Number = int | float

@overload
def nwise(iterable: Iterable[T], n: Literal[1]) -> Iterable[tuple[T]]: ...
@overload
def nwise(iterable: Iterable[T], n: Literal[2]) -> Iterable[tuple[T, T]]: ...
@overload
def nwise(iterable: Iterable[T], n: Literal[3]) -> Iterable[tuple[T, T, T]]: ...
@overload
def nwise(iterable: Iterable[T], n: Literal[4]) -> Iterable[tuple[T, T, T, T]]: ...
@overload
def nwise(iterable: Iterable[T], n: Literal[5]) -> Iterable[tuple[T, T, T, T, T]]: ...
@overload
def nwise(
    iterable: Iterable[T], n: Literal[6]
) -> Iterable[tuple[T, T, T, T, T, T]]: ...
@overload
def nwise(iterable: Iterable[T], n: int) -> Iterable[tuple[T, ...]]: ...
@overload
def first(iterable: Iterable[T]) -> T: ...
@overload
def first(iterable: Iterable[T], default: U) -> T | U: ...
@overload
def grouped(iterable: Iterable[T], n: Literal[2]) -> Iterable[tuple[T, T]]: ...
@overload
def grouped(iterable: Iterable[T], n: Literal[3]) -> Iterable[tuple[T, T, T]]: ...
@overload
def grouped(iterable: Iterable[T], n: Literal[4]) -> Iterable[tuple[T, T, T, T]]: ...
@overload
def grouped(iterable: Iterable[T], n: Literal[5]) -> Iterable[tuple[T, T, T, T, T]]: ...
@overload
def grouped(
    iterable: Iterable[T], n: Literal[6]
) -> Iterable[tuple[T, T, T, T, T, T]]: ...
@overload
def grouped(iterable: Iterable[T], n: int) -> Iterable[tuple[T]]: ...
def flatten(iterable: Iterable[Iterable[T]]) -> Iterable[T]: ...

class Vector:
    @overload
    def __init__(self, x: _Number = 0, y: _Number = 0, /): ...
    @overload
    def __init__(self, x: tuple[_Number, _Number], /): ...
    @property
    def x(self, /) -> _Number: ...
    @property
    def y(self, /) -> _Number: ...
    @property
    def length(self, /) -> _Number: ...
    def normalize(self, /) -> Vector: ...
    def __mul__(self, other: _Number, /) -> Vector: ...
    def __rmul__(self, other: _Number, /) -> Vector: ...
    def __truediv__(self, other: _Number, /) -> Vector: ...
    def __floordiv__(self, other: _Number, /) -> Vector: ...
    def __add__(
        self, other: _Number | Vector | tuple[_Number, _Number], /
    ) -> Vector: ...
    def __radd__(
        self, other: _Number | Vector | tuple[_Number, _Number], /
    ) -> Vector: ...
    def __sub__(
        self, other: _Number | Vector | tuple[_Number, _Number], /
    ) -> Vector: ...
    def __rsub__(
        self, other: _Number | Vector | tuple[_Number, _Number], /
    ) -> Vector: ...
    def __lt__(
        self, other: _Number | Vector | tuple[_Number, _Number], /
    ) -> Vector: ...
    def __le__(
        self, other: _Number | Vector | tuple[_Number, _Number], /
    ) -> Vector: ...
    def __eq__(
        self, other: _Number | Vector | tuple[_Number, _Number], /
    ) -> Vector: ...
    def __ne__(
        self, other: _Number | Vector | tuple[_Number, _Number], /
    ) -> Vector: ...
    def __ge__(
        self, other: _Number | Vector | tuple[_Number, _Number], /
    ) -> Vector: ...
    def __gt__(
        self, other: _Number | Vector | tuple[_Number, _Number], /
    ) -> Vector: ...
    def __iter__(self, /) -> Iterator[_Number]: ...
    def __str__(self, /) -> str: ...
    def __repr__(self, /) -> str: ...
    def __hash__(self, /) -> int: ...

class Direction(Enum):
    UP_LEFT = Vector(-1, -1)
    UP = Vector(0, -1)
    UP_RIGHT = Vector(1, -1)
    LEFT = Vector(-1, 0)
    RIGHT = Vector(1, 0)
    DOWN_LEFT = Vector(-1, 1)
    DOWN = Vector(0, 1)
    DOWN_RIGHT = Vector(1, 1)

CARDINAL_DIRECTIONS = (Direction.UP, Direction.DOWN, Direction.LEFT, Direction.RIGHT)

def range2d(width: int, height: int) -> Iterable[Vector]: ...
def make_direction_range(
    height: int, width: int, *direction: Direction | Vector | tuple[int, int]
) -> Callable[[Vector], Iterable[Vector]]: ...
def make_direction_ranges(
    height: int, width: int, *directions: Direction | Vector | tuple[int, int]
) -> tuple[Callable[[Vector], Iterable[Vector]], ...]: ...
